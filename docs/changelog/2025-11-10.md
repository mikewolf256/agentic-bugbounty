### How to implement this cleanly

**Architecture options (pick 1–2):**

1. **Kubernetes CronJobs + cluster autoscaling (Karpenter/CA) + Spot nodes**
    
    - Define a `CronJob` per scope (or per scope-group).
        
    - Let autoscaler bring nodes up **just-in-time**; scale back to zero when jobs complete.
        
    - Prefer **Spot** capacity; jobs are retryable if a node is reclaimed.
        
2. **AWS Fargate or AWS Batch (with Spot)**
    
    - Pay per vCPU-second; scales to zero between jobs.
        
    - Great if you don’t want to manage nodes; Batch handles queues, retries, and array jobs.
        
3. **KEDA + a queue (SQS/PubSub)**
    
    - Push scan tasks to the queue; **KEDA** scales worker deployments up when there’s backlog, down to 0 when empty.
        
    - Lets you burst higher than “30 workers” if needed for a big run.
        

**Tactical tips to keep it cheap (and fast):**

- **Checkpoint & resume** scan phases (DNS/crawl/wordlists) so interruptions don’t waste effort.
    
- **Diff-driven runs**: skip heavy scans if nothing changed (ETag/Last-Modified, sitemap, robots, headers, build IDs, hash of JS bundles).
    
- **Rate-limit & target awareness**: align with program rules; you’ll avoid bans and reduce noisy retries.
    
- **Shared caches** (e.g., DNS, wordlists, fingerprints) in a read-only PVC or S3 to cut I/O time.
    
- **Short, focused jobs** (e.g., 15–30 min) to maximize Spot survivability and scheduling flexibility.