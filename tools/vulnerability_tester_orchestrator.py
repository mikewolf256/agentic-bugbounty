#!/usr/bin/env python3
"""Vulnerability Tester Orchestrator - Orchestrates calling all vulnerability testers.

This module provides functions to automatically call all 15 new vulnerability testers
based on discovered URLs, profile settings, and scope validation.
"""

import os
import time
from typing import Dict, Any, List, Optional
from urllib.parse import urlparse

# MCP server URL (can be overridden via environment)
MCP_SERVER_URL = os.environ.get("MCP_URL", "http://127.0.0.1:8000")


def _mcp_post(endpoint: str, data: Dict[str, Any]) -> Dict[str, Any]:
    """Make POST request to MCP server."""
    import requests
    url = f"{MCP_SERVER_URL}{endpoint}"
    response = requests.post(url, json=data, timeout=300)
    response.raise_for_status()
    return response.json()


# Tester priority order (by impact)
TESTER_PRIORITY = [
    # Critical RCE (highest priority)
    ("command_injection", "/mcp/run_command_injection_checks", "Command Injection"),
    ("path_traversal", "/mcp/run_path_traversal_checks", "Path Traversal"),
    ("file_upload", "/mcp/run_file_upload_checks", "File Upload"),
    # High-impact auth bypass
    ("nosql_injection", "/mcp/run_nosql_injection_checks", "NoSQL Injection"),
    ("ldap_injection", "/mcp/run_ldap_injection_checks", "LDAP Injection"),
    # Medium-high impact RCE
    ("ssi_injection", "/mcp/run_ssi_injection_checks", "SSI Injection"),
    # Medium impact
    ("csrf", "/mcp/run_csrf_checks", "CSRF"),
    ("mass_assignment", "/mcp/run_mass_assignment_checks", "Mass Assignment"),
    ("secret_exposure", "/mcp/run_secret_exposure_checks", "Secret Exposure"),
    ("websocket", "/mcp/run_websocket_checks", "WebSocket Security"),
    ("crypto_weakness", "/mcp/run_crypto_checks", "Crypto Weakness"),
    # Lower priority
    ("parameter_pollution", "/mcp/run_parameter_pollution_checks", "Parameter Pollution"),
    ("dns_rebinding", "/mcp/run_dns_rebinding_checks", "DNS Rebinding"),
    ("cache_poisoning", "/mcp/run_cache_poisoning_checks", "Cache Poisoning"),
    ("random_generation", "/mcp/run_random_generation_checks", "Random Generation"),
]


def should_run_tester(tester_name: str, profile: Dict[str, Any], discovered_urls: List[str]) -> bool:
    """Determine if a tester should be run based on profile and discovered URLs.
    
    Args:
        tester_name: Name of the tester (e.g., "command_injection")
        profile: Profile configuration dict
        discovered_urls: List of discovered URLs from Katana/Nuclei
        
    Returns:
        True if tester should be run, False otherwise
    """
    # Check profile settings
    targeted_tests = profile.get("targeted_vuln_tests", {})
    if isinstance(targeted_tests, dict):
        # Check if tester is explicitly disabled
        if tester_name in targeted_tests and targeted_tests[tester_name] is False:
            return False
        # Check if tester is explicitly enabled
        if tester_name in targeted_tests and targeted_tests[tester_name] is True:
            return True
        # Check if all testers are disabled
        if targeted_tests.get("enabled", True) is False:
            return False
    
    # Default: run all testers if not specified
    return True


def run_targeted_vulnerability_tests(
    host: str,
    discovered_urls: List[str],
    profile: Dict[str, Any],
    use_callback: bool = False
) -> Dict[str, Any]:
    """Run all targeted vulnerability tests for a host.
    
    This function orchestrates calling all 15 new vulnerability testers based on:
    - Discovered URLs from Katana/Nuclei
    - Profile settings (which testers to run)
    - Scope validation (handled by MCP endpoints)
    
    Args:
        host: Host being tested (e.g., "localhost:5013")
        discovered_urls: List of discovered URLs from Katana/Nuclei
        profile: Profile configuration dict
        use_callback: Whether to use callback-based detection (for OOB vulnerabilities)
        
    Returns:
        Dict with aggregated test results:
        {
            "tests_run": int,
            "tests_passed": int,
            "tests_failed": int,
            "findings": List[Dict],
            "results_by_tester": Dict[str, Dict]
        }
    """
    results = {
        "tests_run": 0,
        "tests_passed": 0,
        "tests_failed": 0,
        "findings": [],
        "results_by_tester": {},
        "errors": []
    }
    
    # Extract base URL from host
    if not host.startswith("http://") and not host.startswith("https://"):
        base_url = f"http://{host}"
    else:
        base_url = host
    
    # Parse host to get netloc
    parsed = urlparse(base_url)
    host_netloc = parsed.netloc or parsed.path.split("/")[0]
    
    print(f"[VULN-TESTER] Running targeted vulnerability tests for {host_netloc}")
    print(f"[VULN-TESTER] Discovered {len(discovered_urls)} URLs")
    
    # Pre-flight: List all testers and their enabled/disabled status
    enabled_testers = []
    disabled_testers = []
    for tester_name, endpoint, display_name in TESTER_PRIORITY:
        if should_run_tester(tester_name, profile, discovered_urls):
            enabled_testers.append(display_name)
        else:
            disabled_testers.append(display_name)
    
    print(f"[VULN-TESTER] Enabled testers ({len(enabled_testers)}): {', '.join(enabled_testers)}")
    if disabled_testers:
        print(f"[VULN-TESTER] Disabled testers ({len(disabled_testers)}): {', '.join(disabled_testers)}")
    print(f"[VULN-TESTER] Starting test execution...")
    print("")
    
    # Track all testers for summary
    tester_status = {}  # tester_name -> {"status": "run|skipped|error", "elapsed": float, "findings": int}
    
    # Run testers in priority order
    for tester_name, endpoint, display_name in TESTER_PRIORITY:
        if not should_run_tester(tester_name, profile, discovered_urls):
            print(f"[VULN-TESTER] ‚è≠Ô∏è  Skipping {display_name} (disabled in profile)")
            tester_status[tester_name] = {
                "status": "skipped",
                "reason": "disabled in profile",
                "elapsed": 0.0,
                "findings": 0
            }
            continue
        
        start_time = time.time()
        try:
            print(f"[VULN-TESTER] üß™ Testing {display_name}...")
            
            # For command injection, test each relevant URL separately to catch all endpoints
            if tester_name == "command_injection":
                # Find all URLs that might have command injection
                command_urls = [url for url in discovered_urls if any(
                    keyword in url.lower() for keyword in ["execute", "upload", "api", "run", "cmd", "command"]
                )]
                if not command_urls:
                    # Fallback: test all discovered URLs (they might have command injection even without keywords)
                    command_urls = discovered_urls
                
                print(f"[VULN-TESTER] Command Injection: Testing {len(command_urls)} URLs")
                if command_urls:
                    print(f"[VULN-TESTER]   URLs: {', '.join(command_urls[:5])}{'...' if len(command_urls) > 5 else ''}")
                
                tester_findings = []
                for test_url in command_urls:
                    # Prepare request for this specific URL
                    request_data = _prepare_tester_request(tester_name, test_url, [test_url], use_callback)
                    if request_data:
                        # Override target_url to use the specific URL
                        request_data["target_url"] = test_url
                        try:
                            test_result = _mcp_post(endpoint, request_data)
                            
                            vulnerable = test_result.get("vulnerable", False)
                            findings_count = test_result.get("findings_count", 0)
                            if findings_count == 0 and "meta" in test_result:
                                findings_count = test_result["meta"].get("findings_count", 0)
                            
                            if vulnerable or findings_count > 0:
                                # Extract findings from MCP response
                                # MCP endpoint returns findings in the response or in findings_file
                                findings_extracted = False
                                
                                # Try to get findings directly from response
                                if "findings" in test_result and isinstance(test_result["findings"], list):
                                    for finding in test_result["findings"]:
                                        # Ensure finding has target_url set
                                        if not finding.get("target_url"):
                                            finding["target_url"] = test_url
                                        tester_findings.append(finding)
                                    findings_extracted = True
                                
                                # Fallback: try to read from findings_file
                                if not findings_extracted and "findings_file" in test_result:
                                    findings_file = test_result.get("findings_file")
                                    if findings_file and os.path.exists(findings_file):
                                        import json
                                        try:
                                            with open(findings_file, 'r') as f:
                                                findings_data = json.load(f)
                                                if isinstance(findings_data, dict) and "findings" in findings_data:
                                                    if isinstance(findings_data["findings"], list):
                                                        for finding in findings_data["findings"]:
                                                            # Ensure finding has target_url set
                                                            if not finding.get("target_url"):
                                                                finding["target_url"] = test_url
                                                            tester_findings.append(finding)
                                                        findings_extracted = True
                                        except Exception as e:
                                            print(f"[VULN-TESTER] Warning: Failed to load findings from {findings_file}: {e}")
                                
                                # Create basic finding if none extracted but vulnerable=True
                                if not findings_extracted and vulnerable:
                                    tester_findings.append({
                                        "type": tester_name,
                                        "test": tester_name,
                                        "vulnerable": True,
                                        "target_url": test_url,
                                        "injection_point": test_result.get("injection_point"),
                                        "evidence": {"note": "Vulnerability detected by MCP endpoint"}
                                    })
                        except Exception as e:
                            print(f"[VULN-TESTER] Warning: Failed to test {test_url}: {e}")
                
                elapsed = time.time() - start_time
                results["tests_run"] += 1
                
                if tester_findings:
                    results["tests_passed"] += 1
                    results["findings"].extend(tester_findings)
                    print(f"[VULN-TESTER] ‚úÖ {display_name}: Found {len(tester_findings)} vulnerability/vulnerabilities ({elapsed:.2f}s)")
                    tester_status[tester_name] = {
                        "status": "passed",
                        "elapsed": elapsed,
                        "findings": len(tester_findings)
                    }
                else:
                    results["tests_failed"] += 1
                    print(f"[VULN-TESTER] ‚ùå {display_name}: No vulnerabilities found ({elapsed:.2f}s)")
                    tester_status[tester_name] = {
                        "status": "failed",
                        "elapsed": elapsed,
                        "findings": 0
                    }
                
                results["results_by_tester"][tester_name] = {
                    "vulnerable": len(tester_findings) > 0,
                    "findings_count": len(tester_findings),
                    "elapsed": elapsed,
                    "result": {"findings": tester_findings}
                }
                continue
            
            # Prepare request based on tester type (for non-command-injection testers)
            request_data = _prepare_tester_request(tester_name, base_url, discovered_urls, use_callback)
            
            if not request_data:
                elapsed = time.time() - start_time
                print(f"[VULN-TESTER] ‚è≠Ô∏è  Skipping {display_name} (no suitable URLs found)")
                tester_status[tester_name] = {
                    "status": "skipped",
                    "reason": "no suitable URLs",
                    "elapsed": elapsed,
                    "findings": 0
                }
                continue
            
            # Call MCP endpoint
            test_result = _mcp_post(endpoint, request_data)
            elapsed = time.time() - start_time
            
            results["tests_run"] += 1
            
            # Extract findings from result
            vulnerable = test_result.get("vulnerable", False)
            # Check both direct findings_count and meta.findings_count
            findings_count = test_result.get("findings_count", 0)
            if findings_count == 0 and "meta" in test_result:
                findings_count = test_result["meta"].get("findings_count", 0)
            
            if vulnerable or findings_count > 0:
                results["tests_passed"] += 1
                print(f"[VULN-TESTER] ‚úÖ {display_name}: Found {findings_count} vulnerability/vulnerabilities ({elapsed:.2f}s)")
                tester_status[tester_name] = {
                    "status": "passed",
                    "elapsed": elapsed,
                    "findings": findings_count
                }
                
                # Extract findings from response (prefer direct findings array)
                if "findings" in test_result and isinstance(test_result["findings"], list):
                    results["findings"].extend(test_result["findings"])
                elif "findings" in test_result and isinstance(test_result["findings"], dict):
                    results["findings"].append(test_result["findings"])
                # Fallback: try to read from findings_file (if accessible)
                elif "findings_file" in test_result:
                    findings_file = test_result.get("findings_file")
                    if findings_file and os.path.exists(findings_file):
                        import json
                        try:
                            with open(findings_file, 'r') as f:
                                findings_data = json.load(f)
                                if isinstance(findings_data, list):
                                    results["findings"].extend(findings_data)
                                elif isinstance(findings_data, dict):
                                    # Extract findings array from dict if present
                                    if "findings" in findings_data:
                                        if isinstance(findings_data["findings"], list):
                                            results["findings"].extend(findings_data["findings"])
                                        else:
                                            results["findings"].append(findings_data["findings"])
                                    else:
                                        results["findings"].append(findings_data)
                        except Exception as e:
                            print(f"[VULN-TESTER] Warning: Failed to load findings from {findings_file}: {e}")
                # If no findings extracted but vulnerable=True, create a basic finding
                if vulnerable and len(results["findings"]) == 0:
                    results["findings"].append({
                        "type": tester_name,
                        "test": tester_name,
                        "vulnerable": True,
                        "target_url": test_result.get("target_url", ""),
                        "injection_point": test_result.get("injection_point"),
                        "evidence": {"note": "Vulnerability detected by MCP endpoint"}
                    })
            else:
                results["tests_failed"] += 1
                print(f"[VULN-TESTER] ‚ùå {display_name}: No vulnerabilities found ({elapsed:.2f}s)")
                tester_status[tester_name] = {
                    "status": "failed",
                    "elapsed": elapsed,
                    "findings": 0
                }
            
            results["results_by_tester"][tester_name] = {
                "vulnerable": vulnerable,
                "findings_count": findings_count,
                "elapsed": elapsed,
                "result": test_result
            }
            
        except Exception as e:
            elapsed = time.time() - start_time
            results["tests_failed"] += 1
            results["errors"].append({
                "tester": tester_name,
                "error": str(e)
            })
            print(f"[VULN-TESTER] ‚ùå {display_name} failed: {e} ({elapsed:.2f}s)")
            tester_status[tester_name] = {
                "status": "error",
                "elapsed": elapsed,
                "findings": 0,
                "error": str(e)
            }
            continue
    
    print("")
    print(f"[VULN-TESTER] Completed: {results['tests_run']} tests, {results['tests_passed']} found vulnerabilities, {results['tests_failed']} found none")
    print(f"[VULN-TESTER] Total findings: {len(results['findings'])}")
    
    # Print summary table
    print("")
    print("[VULN-TESTER] ===== Test Summary =====")
    print(f"{'Tester':<30} {'Status':<12} {'Findings':<10} {'Time':<10}")
    print("-" * 65)
    
    for tester_name, endpoint, display_name in TESTER_PRIORITY:
        status_info = tester_status.get(tester_name, {"status": "unknown", "elapsed": 0.0, "findings": 0})
        status = status_info.get("status", "unknown")
        findings = status_info.get("findings", 0)
        elapsed = status_info.get("elapsed", 0.0)
        
        # Format status with emoji
        status_display = {
            "passed": "‚úÖ PASSED",
            "failed": "‚ùå NO VULNS",
            "skipped": "‚è≠Ô∏è  SKIPPED",
            "error": "‚ö†Ô∏è  ERROR",
            "unknown": "‚ùì UNKNOWN"
        }.get(status, status.upper())
        
        print(f"{display_name:<30} {status_display:<12} {findings:<10} {elapsed:.2f}s")
    
    print("-" * 65)
    print(f"Total: {len(TESTER_PRIORITY)} testers | Run: {results['tests_run']} | Passed: {results['tests_passed']} | Failed: {results['tests_failed']} | Skipped: {len([s for s in tester_status.values() if s.get('status') == 'skipped'])}")
    print("")
    
    return results


def _prepare_tester_request(
    tester_name: str,
    base_url: str,
    discovered_urls: List[str],
    use_callback: bool
) -> Optional[Dict[str, Any]]:
    """Prepare request data for a specific tester.
    
    Args:
        tester_name: Name of the tester
        base_url: Base URL of the target
        discovered_urls: List of discovered URLs
        use_callback: Whether to use callback-based detection
        
    Returns:
        Request data dict or None if tester shouldn't run
    """
    # Most testers need a target_url
    # Use base_url as default, or try to find a relevant URL from discovered_urls
    
    if tester_name == "command_injection":
        # Command injection tester - test each relevant URL separately
        # Find all URLs that might have command injection
        command_urls = []
        for url in discovered_urls:
            if any(keyword in url.lower() for keyword in ["execute", "upload", "api", "run", "cmd", "command"]):
                command_urls.append(url)
        if not command_urls:
            command_urls = [base_url]
        
        # Return first URL with common parameters (orchestrator will handle multiple URLs)
        target_url = command_urls[0] if command_urls else base_url
        # Common command injection parameter names
        params = ["cmd", "command", "exec", "execute", "run", "system", "filename"]
        return {"target_url": target_url, "params": params, "use_callback": use_callback}
    
    elif tester_name in ["path_traversal", "file_upload", 
                       "ssi_injection", "parameter_pollution", "cache_poisoning"]:
        # These testers work with any URL
        # Prefer URLs with parameters or forms
        target_url = base_url
        for url in discovered_urls:
            if "?" in url or any(method in url.lower() for method in ["post", "form", "upload"]):
                target_url = url
                break
        return {"target_url": target_url, "use_callback": use_callback}
    
    elif tester_name in ["nosql_injection", "ldap_injection"]:
        # These testers need login/auth endpoints
        target_url = base_url
        for url in discovered_urls:
            if any(keyword in url.lower() for keyword in ["login", "auth", "signin", "authenticate"]):
                target_url = url
                break
        return {"target_url": target_url, "use_callback": use_callback}
    
    elif tester_name == "csrf":
        # CSRF needs host (not target_url) and optionally endpoints
        from urllib.parse import urlparse
        parsed = urlparse(base_url)
        host = parsed.netloc or parsed.path.split("/")[0]
        return {"host": host, "endpoints": None, "auth_context": None}
    
    elif tester_name == "mass_assignment":
        # Needs API endpoints - requires both target_url AND endpoint
        api_endpoint = base_url
        for url in discovered_urls:
            if "/api/" in url or url.endswith("/user") or url.endswith("/profile"):
                api_endpoint = url
                break
        from urllib.parse import urlparse
        parsed = urlparse(base_url)
        target_url = f"{parsed.scheme}://{parsed.netloc}"
        return {"target_url": target_url, "endpoint": api_endpoint}
    
    elif tester_name == "secret_exposure":
        # Needs host (not target_url) - preserve port for localhost
        from urllib.parse import urlparse
        # Ensure base_url has a scheme for proper parsing
        if not base_url.startswith(("http://", "https://")):
            base_url = f"http://{base_url}"
        parsed = urlparse(base_url)
        host = parsed.netloc or parsed.path.split("/")[0]
        # Keep port for localhost (needed for local testing), remove for other hosts
        if not (host.startswith("localhost") or host.startswith("127.0.0.1")):
            # Remove port for non-localhost hosts (MCP endpoint will use https://)
            if ":" in host:
                host = host.split(":")[0]
        # Validate host is not empty
        if not host:
            return None  # Skip if we can't determine host
        return {"host": host, "scan_js": True, "scan_responses": True, "validate_secrets": True}
    
    elif tester_name == "websocket_security":
        # Needs endpoint (not target_url) - WebSocket URL
        ws_endpoint = None
        for url in discovered_urls:
            if "ws://" in url or "wss://" in url:
                ws_endpoint = url
                break
            elif "/socket.io" in url or "/ws" in url or url.endswith("/ws"):
                # Convert HTTP to WS for likely WebSocket endpoints
                ws_endpoint = url.replace("http://", "ws://").replace("https://", "wss://")
                break
        # Only convert HTTP to WS if we found a likely WebSocket endpoint
        if not ws_endpoint:
            # Look for endpoints that might support WebSocket
            for url in discovered_urls:
                if any(keyword in url.lower() for keyword in ["socket", "ws", "realtime", "stream"]):
                    # Convert HTTP to WS
                    ws_endpoint = url.replace("http://", "ws://").replace("https://", "wss://")
                    break
        # If still no endpoint found, skip this tester
        if not ws_endpoint or not (ws_endpoint.startswith("ws://") or ws_endpoint.startswith("wss://")):
            return None  # Skip if no valid WebSocket endpoint found
        return {"endpoint": ws_endpoint, "origin": None, "subprotocols": None}
    
    elif tester_name in ["crypto_weakness", "random_generation"]:
        # Needs login/token endpoints
        target_url = base_url
        for url in discovered_urls:
            if any(keyword in url.lower() for keyword in ["login", "token", "session", "auth"]):
                target_url = url
                break
        return {"target_url": target_url}
    
    elif tester_name == "dns_rebinding":
        # Needs SSRF-like endpoints
        target_url = base_url
        for url in discovered_urls:
            if any(keyword in url.lower() for keyword in ["fetch", "proxy", "request", "url"]):
                target_url = url
                break
        return {"target_url": target_url, "use_callback": use_callback}
    
    else:
        # Default: use base_url
        return {"target_url": base_url, "use_callback": use_callback}

